分業構造による業務の効率化
一つの製品を作る工程を一人でなく数人に分けて作業内容も分担数ることで生産性を効率化できる。
アダム・スミスの提唱した分業による生産性の向上、専門化による熟練度工場（学習効果）、仕事の切り替えロス（タイムロスを減らせる）、専門工具や専用工具の発明を誘発（専門性の向上、更なる効率化）。
また分業にも自社でするか他社でするかによりさらに細かく利益を出す方法や作成する工程にも細工を凝らす必要がある。
しかし昨今ではEV車を作成する工場などにおけるベルトコンベアの廃止や、大量にある車のパーツを一纏めに作成できる機会(専門的な機会)の誕生により分業ではなく製品の作成工程の単純化も進んでいる。
分業化が簡単になるとバリューチェーンの管理も簡単になりそう？
スライド７のQに対するA
自社でしかできない事を売りにする。
製品価格に合わせてグレードを作る。








・内容：従業員データを用いて
  1. 部署の単純集計を行い、棒グラフで表示せよ
  2. 部署と離職のクロス集計を行い、100％積み上げ棒グラフで表示せよ
  3. 給料のヒストグラムを表示せよ
  4. 給料の平均値と標準偏差を計算せよ
  5. 以上のことから、従業員データの特徴をまとめよ。
　　　ただし、部署、離職、給料、平均値、標準偏差という言葉はかならず使うこと。
・提出形式：A4で2枚以内（3枚目以上は採点されない。改行幅に注意）。ファイル形式はワードもしくはPDF。
本文中に学籍番号、名前がないものは採点されない。
・提出方法：クラスルームからGoogleフォームに移動し、提出（ここに提出しても採点されない）
・提出期限：5月13日23:59


I'm a beginner at Geogesser. This game is very fun and has become my favorite lately. I wanted to play more, so I bought a pro account for one month, but I accidentally bought a year's account. Can I get a refund?
I am a beginner in English, so please forgive me if my phrasing is strange.






分業、何故中小企業は偏在するのか
メガネで言うと過去には帳場事にグループ分けされて腕を磨いていた→街そのものが1つのグループに
今ではひとつの街が(福井さかえ)高い技術を持ったメガネの産地にシェア90%
Face to Face、近ければ近いほど情報交換がしやすくて良い(物も運びやすい)、レンズは工程が違うので他の地域で作られている
OEMは便利で継続した利益が出るがデメリットは大きく、依存度が高くなりOEMに頼り自社の開発力の低下が起きることや、OEMが途絶え売り上げに響いたりする
だがOEMを行っている企業は沢山ある。




もしアンケートを行うなら属性の頼り（国立のみ、私立のみなど）に気を付ける、

尺度水準
スティーブンスの４つの尺度
名義尺度、データを幾つかのグループやカテゴリにする尺度。
順位尺度、データの大きい順に順位を割り振る時に用居られる。大小関係は示せるが、順位の間が等間隔だとは限らない。（四則計算厳禁）
間隔尺度、温度や暦、数値の大小関係が明白、原点が任意に置ける。加減は可能だが倍数関係に言及できない。
比率尺度、身長、タイム、時間など物理量を示す尺度。０がない

そこそこ、まあまあ、めったに、たまに、などは人により数値化した時の値が違うので要注意。



就職の進め方とスケジュール
マイナビ2026の登録
インターシップ＆キャリアについて

６月が就活（インターンのエントリー）スタートと言われているが実際は30％強の人がすでに内定が決まっている。
4月１日からエントリー（情報収集）





認められました 大家族で5人ぐらいです ゆう機会も出てきたので 機械化もできたので1人でいい ディナそれを表す 女性用のタモが日本語にはないのね 言い方をしていますから 要は長男以外の人が働ける作業力が日本全国でですね 農業から工場とか 労働力不足して回収をします 1970年でできてですね 1974年から1990年 総理大臣には大きな事件 多いと思います 私 小学校3年生の時でしたけどもですね アメリカの財政が危機になるー 以降です 
相場が変動するのは今これ いつか 1971 円ですよ ということで 国ごとに ですね 各国の通貨とドル そのこの相場は常に変動するということにしましょうということであったわけです 上昇しました 150円とかですね





中小企業は、産業政策の中でも重要なテーマである。
戦後復帰と中小企業1945-56
収奪問題、親企業による加工単価切り下げ。
経営資源問題、内部資金が蓄積できず設備投資ができない。国は第一に大企業を優先。これにより近代化した大企業と前近代的な中小企業群の二重構造問題と呼ばれる構造が生まれた。
pbは一度に大量に商品の発注をする、パッケージ（デザイン）の簡易化、品質の管理により元の製品よりもさらに安くすることが出来ている。











サプライチェーンとは
プライベートブランド
大手が小売店向けに安くプライベートブランドとして売る


ファブレスチェーン

今後の授業
相関分析
ｔ検定

相関とは、二つの量的変数の間にみられる共変関係（比例、反比例など？）
グラフは噓をつく、同じ縦軸でも値が違うなど。
相関とは2-1、一般的に相関とは「ピアソンの相関係数」が用いられる。相関の例、身長と体重、収入と購買金額など
相関2-2、相関の持つ意味と特徴。正の相関、負の相関
相関関係の強弱の目安、r=0無相関、～0.3弱い相関、～0.7中程度の相関、0.7～強い相関
相関2-3、相関関係の注意（疑似相関）本当は相関が無いのに第三の変数により見かけ上現れる相関関係
相関関係の注意２、外れ値の影響、外れ値は除くと正しいｒが見える



就職の進め方とスケジュール
マイナビ2026の登録
インターシップ＆キャリアについて

６月が就活（インターンのエントリー）スタートと言われているが実際は30％強の人がすでに内定が決まっている。
4月１日からエントリー（情報収集）

問題文
2 次元グリッド上に 
2 つの図形 
S と 
T があります。グリッドは正方形のマスからなります。

S は 
N 行 
N 列のグリッド内にあり、
S 
i,j
​
  が # であるようなマス全体からなります。
T も 
N 行 
N 列のグリッド内にあり、
T 
i,j
​
  が # であるようなマス全体からなります。

S と 
T を 
90 度回転及び平行移動の繰り返しによって一致させることができるか判定してください。

入力例
5
.....
..#..
.###.
.....
.....
.....
.....
....#
...##
....#

pythonで

この問題を解決するために、まずは図形の回転と平行移動をどのように実装するかを考える必要があります。その後、与えられた図形を回転・平行移動させて一致させることができるかどうかを判定するアルゴリズムを作成します。

以下は、Pythonでこの問題を解決するための一般的なアプローチです。

図形の回転: 与えられた図形を時計回りに90度回転する関数を作成します。これにより、図形の向きを変えることができます。
図形の平行移動: 与えられた図形を上下左右に移動させる関数を作成します。これにより、図形を正しい位置に配置することができます。
一致判定: 回転と平行移動を組み合わせ、SとTが一致するかどうかを判定します。
以下は、Pythonでの具体的な実装例です。


def rotate_shape(shape):
    # 図形を時計回りに90度回転する関数
    return list(zip(*reversed(shape)))

def translate_shape(shape, dx, dy):
    # 図形を上下左右にdx, dyだけ移動する関数
    return [(x + dx, y + dy) for x, y in shape]

def check_matching(S, T):
    # 図形SとTが一致するかどうかを判定する関数
    for _ in range(4):  # 回転を4回繰り返す（360度）
        for dx in range(-len(S), len(S) + 1):
            for dy in range(-len(S), len(S) + 1):
                # Sをdx, dyだけ平行移動
                translated_S = translate_shape(S, dx, dy)
                if sorted(translated_S) == sorted(T):
                    return True
        # Sを90度回転
        S = rotate_shape(S)
    return False

# 入力の受け取り
N = int(input().strip())
S = []
T = []
for _ in range(N):
    S.append(input().strip())
for _ in range(N):
    T.append(input().strip())

# 図形の#の位置を取得
S_shape = [(i, j) for i in range(N) for j in range(N) if S[i][j] == "#"]
T_shape = [(i, j) for i in range(N) for j in range(N) if T[i][j] == "#"]

# SとTが一致するかどうかを判定して結果を出力
if check_matching(S_shape, T_shape):
    print("Yes")
else:
    print("No")

このコードでは、与えられたSとTの図形を#の位置で表現し、回転と平行移動を行いながら一致判定を行います。


人口は購買力

私たちが生きてるうちに日本の人口はどんどん減ってゆく、そうすると年金がすごく減ってしまう
雇用にはいろいろな形がある、主な違いは正規雇用なのか非正規雇用なのか。正規雇用は総合職、一般社員があり転勤の可能性がる。非正規雇用は契約社員やパート、アルバイトがある
店長になりたければ総合職
また正規雇用であって
も総合職、一般職でも全然給料が違う




グローバルニッチトップ企業
カンデオホテル,隙間として残っている（ニッチな）需要はあるけど宿が少ないところにラグジュアリーほど高くなくビジネスホテルほど安くない、星４つホテルとして需要を二いいとこどりしている。最初はビジネスホテルにしては高い。高級ホテルにしては設備が、、と言われていたが徐々に浸透してきている。飲食のできるレストランへの投資あえて減らし地域にも還元しつつコスト削減もしている。
ニッチトップ企業のメリットである先発者収益も見込まれるが、業種よっては他社がまねをしやすくブルーオーシャンではなくなることもありそう。



Vector3 offset:
public GameObject ball;



6 6
######
#....#
#.#..#
#..#.#
#....#
######


6 6
abcdif
ghijkl
mnopqr
stu#.#
#....#
######


    void FixedUpdeat()
    {
        Rigidbody rb = gameObject.GetComponent<Rigidbody>();
        if (rb.velocity.magnitude>Limtspeed)
        {
            rb.velocity=new Vector3(rb.velocity.x/1.1f,rb.velocity.z/1.1f);
        }
    }




using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//using UnityEngin.SceneManagement;
//using UnityEngin.SceneManagement;

public class BallController : MonoBehaviour
{



    //public GameObject gg;
    //oniをとる　あたるとリセット
    // Start is called before the first frame update
    void Start()
    {
        
    }



    // Update is called once per frame
    //void OnTriggerEnter(Collider hit)
    //{
    //    if (hit.gameObject==oni)
    //    {
    //        SceneManager.Loadcene(SceneManager.GetActiveScene().name);
    //    }
    //}



    void Update()
    {
        
        //Debug.Log('Yes')       
        //[SerializeField]                
        //float LimitSpeed = 15f; // 変数名を「LimitSpeed」に修正（大文字の「L」を小文字の「l」に）
        [SerializeField]                
        float LimitSpeed = 15f; // 変数名を「LimitSpeed」に修正（大文字の「L」を小文字の「l」に）


        float speed = 15.0f;
        Rigidbody rb = gameObject.GetComponent<Rigidbody>();
        
        if( Input.GetKey(KeyCode.RightArrow) )
            rb.AddForce( Vector3.right * speed);
        if( Input.GetKey(KeyCode.LeftArrow) )
            rb.AddForce( Vector3.left * speed);
        if( Input.GetKey(KeyCode.UpArrow) )
            rb.AddForce( Vector3.forward * speed);
        if( Input.GetKey(KeyCode.DownArrow) )
            rb.AddForce( Vector3.back * speed);
        if( Input.GetKey(KeyCode.Space) )
            rb.AddForce( Vector3.up * speed/2);
    }
    void FixedUpdate()
{
    Rigidbody rb = gameObject.GetComponent<Rigidbody>();
    if (rb.velocity.magnitude > LimitSpeed)
    {
        rb.velocity = new Vector3(rb.velocity.x / 1.1f, rb.velocity.y, rb.velocity.z / 1.1f);
    }

}


}

########################################################################################

sy = 2
sx = 2
y=1
x=1
direction = [(-1, 0,"U"), (0, 1, "R"), (1, 0, "D"), (0, -1, "L")]
# 上、右、下、左

seen = set()
ans = 0
#for _ in range((n-2)*(m-2)):
print(ita)
print(type(ita))
#print('tt',ita[1][1])
while ikuroko








for _ in range(x*y*4):
    #↑これわからん
    print('f11')
    for dy, dx, di in direction:
        print('f2')
        #y = sy
        #x = sx
        while True:
            y+= dy
            x+= dx
            #print(y,x)
            if x < 1 or x > n or y < 1 or y > m:
                print('hani',x,y,ita[x][y],di)
                #上下か判定
                y-=dy
                x-=dx
                break
            elif ita[x][y] == '#':
                print("iwwa",x,y,ita[x][y],di)
                #岩か判定
                y-=dy
                x-=dx
                break
            elif ita[x][y] == '.':
                #氷か判定
                if (x, y) not in seen:
                    print("kori",x,y,ita[x][y],di)
                    #既視か判定
                    seen.add((x, y))
                    ans+= 1


#import sys
#input = sys.stdin.read

#data = list(map(str,input().splitlines()))
#n, m = map(int, data[0].split())
#ita = list(data[1:n+1])
#ita = list(data[1:])

#######################################
ita=[]
n,m=map(int,input().split())
#for _ in range(n):
#    ita.append(list(map(str,input().split())))
#print(data)
for _ in range(n):
    ita.append(list(input()))
ita[1][1]='x'
print(ita)

x=1
y=1
direction = [(-1, 0, 0), (0, 1, 1), (1, 0, 2), (0, -1, 3)]
#上、右、下、左
wilt=[]
ct=0
place=0
for dy,dx,di in direction:
    #print(dx,dy,di)
    #if ita[dx][dy] == 
    y+=dy
    x+=dx
    if x < 1 or x > n or y < 1 or y > m:
        print('hani',x,y,ita[x][y],di)
        #上下か判定
        y-=dy
        x-=dx
        #break
    if ita[y][x] == '#':
        print("iwwa",y,x,ita[y][x],di)
        #岩か判定
        y-=dy
        x-=dx
        #break
    elif ita[y][x] == '.':
        ita[y][x]='x'
        wilt.append((y,x,di))
        place+=1
        y-=dy
        x-=dx
        #↑不都合出るかも要注意(x-dx,y-dy,di)
print(wilt)
print(ita[1][1])
now=0

#while place != 0:
#    now=ita[ct]
#    if now[2]=="U":

for u in ita:
    print(u)

##########################################################


print(ita[1][1])
now=0
print('place',place)
print(wilt)
while place != 0:
    y,x,di  = wilt[ct]
    print('y,x,di',y,x,di)
    dy,dx,z = direction[di]
    print('dy,dx,z',dy,dx,z)
    while ita[y][x] != '#':
        print('Z',ita[y][x],y,x)
        if ita[y][x] =='.':
            print('.=x')
            ita[x][y]='s'
        else:
            ita[y][x]='n'
        y+=dy
        x+=dx
        #print(dy,dx)
    place-=1
    ct+=1


###################################################################
    
n,m,h,k=map(int,input().split())
s=input()
da={}
x=0
y=0
xi=0
yi=0
da[22,22]=5
for u in range(m):
    xi,yi=map(int,input().split())
    if (x,y) not in da:
        da[(xi,yi)]=1

for i in s:
    h-=1
    xi=0
    yi=0
    if h<0:
        print('No')
        break

    if   i == 'R':
        xi+=1                            
    elif i == 'L':
        xi-=1
    elif i == 'U':
        yi-=1
    elif i == 'D':
        yi+=1
    x+=xi
    y+=yi
    if h < k:
        if (x,y) in da:
            if da[(x,y)]>0:
                h=k
                da[(x,y)]-=1
else:
    print('Yes')
# 5 2 1 5
# LDRLD
# 0 0
# -1 -1
# https://atcoder.jp/contests/adt_medium_20240711_2/tasks