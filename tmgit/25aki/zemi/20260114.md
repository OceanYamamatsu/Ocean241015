了解。では **「正解ルートをなぞった説明」ではなく**、
**あなたが実際に辿った行動・試行錯誤・失敗も含めた手順**として、
レポートにそのまま使える形で整理します。
（技術系レポートとして評価されやすい書き方にしてあります）

---

## 本課題において実際に行った手順と試行錯誤の記録

本CTF課題「head-dump」では、Webアプリケーションに存在する隠されたエンドポイントを探索し、サーバのメモリダンプからフラグを取得することが目的であった。以下に、実際に自分が行った調査・操作の流れを、失敗や試行錯誤も含めて記す。

### 1. Webページの取得と初期の誤解

最初に `wget` を用いて問題のWebサイトを取得したところ、`index.html` のみが保存され、他のファイルが見当たらなかった。この時点では「必要な情報が不足している」と考え、`wget` の使い方が不十分であることに気づいた。

そこで、Webページ単体ではなく、サイト全体（HTML、JavaScript、画像など）を再帰的に取得する必要があると判断し、`wget -m` 等のオプションを用いてサイト全体をダウンロードした。

### 2. api-docs ディレクトリの発見

再帰的に取得したファイル群を確認したところ、`api-docs` および `api-docs.html` というディレクトリ／ファイルが存在することに気づいた。
この名称から、API仕様を示すSwagger UI（API Documentation）である可能性が高いと考え、ここを重点的に調査する方針に切り替えた。

### 3. Swagger UI の構造調査

`api-docs` ディレクトリ内には `swagger-ui-init.js` が存在しており、Swagger UI の初期化処理が記述されていることが分かった。
当初は `grep` によって URL や json を直接探そうとしたが、ファイルが非常に長く、grep の実行を途中で中断（Ctrl+C）してしまう場面もあった。

その後、`less` を用いてファイルを閲覧し、Swagger UI がどのように API 定義を読み込んでいるかを確認した。

### 4. swaggerDoc が埋め込まれていることの理解

`swagger-ui-init.js` 内を精査した結果、

* `var options = { "swaggerDoc": { ... } }`
* `var spec1 = options.swaggerDoc`
* `url = options.swaggerUrl || url`

という記述を確認した。
ここから、Swagger UI が外部の `openapi.json` を取得しているのではなく、**OpenAPI仕様（API設計情報）が JavaScript 内に直接埋め込まれている**ことを理解した。

この段階で、「API定義ファイルを探す」のではなく、「このファイル内の paths を直接解析する」方針に切り替えた。

### 5. paths から実在するエンドポイントの列挙

`"paths"` が定義されている行を起点に、その範囲から API パスを抽出したところ、以下のエンドポイントが存在することが分かった。

* `/about`
* `/api/posts`
* `/api/posts/{id}`
* `/services`
* `/heapdump`

この中で、課題名「head-dump」および問題文の「The head was dumped」という記述から、`/heapdump` が目的のエンドポイントであると判断した。

### 6. ポート番号による失敗と修正

CTF環境ではインスタンス起動ごとにポート番号が変化するため、過去に確認した別ポート（例：60000番台）で `/heapdump` を叩いた際には 404 エラーが発生した。

そこで、**現在ブラウザでアクセスしているURLと同一のポート番号**を用いる必要があると再認識し、正しいポート番号（64365）を指定して再実行した。

### 7. heapdump の取得と解析

正しいポートで `/heapdump` にアクセスした結果、約11MBのファイルが正常に取得できた。このファイルは `application/octet-stream` として保存されたが、中身はASCIIテキストを含むメモリダンプであった。

ファイル全体を直接読むのは現実的でないため、`strings` コマンドを用いて可読文字列を抽出し、CTFで一般的なフラグ形式である `picoCTF{}` を検索した。

その結果、メモリダンプ内から `picoCTF{...}` 形式の文字列を確認し、フラグを取得することができた。

---

## まとめ

本課題では、単にエンドポイントを当てずっぽうで探すのではなく、

* Webサイト全体を取得すること
* API Documentation（Swagger UI）に着目すること
* 外部ファイルではなく埋め込み仕様である点を理解すること
* 環境ごとに変化するポート番号に注意すること

が重要であった。
また、途中で誤った仮定や操作ミス（grepの中断、誤ったポート指定）もあったが、それらを修正しながら段階的に問題を切り分けたことが、最終的な解決につながった。

---

必要なら

* **字数制限（800字／1000字など）への調整**
* **「学んだこと」「今後にどう活かすか」を追記**
* **よりレポートらしい／より実験記録らしい文体への変更**

もすぐ対応できます。


